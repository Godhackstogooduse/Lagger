-- ServerLoadHarness (Script) - controlled server stress test
-- Commands in server console:
--   _load start
--   _load stop
--   _load status
--   _load set cpuMs 8
--   _load set parts 200
--   _load set throwRate 20
--   _load set duration 60

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local Settings = {
	enabled = false,

	-- CPU burn per Heartbeat step (ms). Keep small; 4-12 is typical for testing.
	cpuMsPerStep = 6,

	-- Simple physics objects to keep the physics solver busy.
	maxParts = 150,

	-- How many impulses per second to apply across parts.
	throwRatePerSec = 15,

	-- Auto-stop after N seconds (0 = no auto-stop)
	durationSec = 60,
}

local partsFolder = Instance.new("Folder")
partsFolder.Name = "_LoadHarnessParts"
partsFolder.Parent = Workspace

local parts = {}
local heartbeatConn: RBXScriptConnection? = nil
local startedAt = 0

local function now() return os.clock() end

local function burnCpu(ms: number)
	if ms <= 0 then return end
	local target = now() + (ms / 1000)
	while now() < target do end
end

local function clearParts()
	for _, p in ipairs(parts) do
		if p and p.Parent then
			p:Destroy()
		end
	end
	table.clear(parts)
end

local function ensureParts()
	-- create up to maxParts
	while #parts < Settings.maxParts do
		local p = Instance.new("Part")
		p.Size = Vector3.new(2, 2, 2)
		p.Anchored = false
		p.CanCollide = true
		p.TopSurface = Enum.SurfaceType.Smooth
		p.BottomSurface = Enum.SurfaceType.Smooth
		p.Position = Vector3.new(
			math.random(-40, 40),
			math.random(15, 35),
			math.random(-40, 40)
		)
		p.Parent = partsFolder
		table.insert(parts, p)
	end

	-- if reduced maxParts, delete extras
	while #parts > Settings.maxParts do
		local p = table.remove(parts)
		if p and p.Parent then p:Destroy() end
	end
end

local throwAccumulator = 0
local function applyPhysics(dt: number)
	if Settings.throwRatePerSec <= 0 or #parts == 0 then return end

	throwAccumulator += dt * Settings.throwRatePerSec
	local throws = math.floor(throwAccumulator)
	if throws <= 0 then return end
	throwAccumulator -= throws

	for _ = 1, throws do
		local p = parts[math.random(1, #parts)]
		if p and p.Parent then
			-- random impulse upward/sideways
			local impulse = Vector3.new(
				math.random(-1200, 1200),
				math.random(800, 1800),
				math.random(-1200, 1200)
			)
			-- ApplyImpulse expects force * mass; impulse is fine here
			p:ApplyImpulse(impulse * p.AssemblyMass)
		end
	end
end

local function stop()
	if not Settings.enabled then return end
	Settings.enabled = false

	if heartbeatConn then
		heartbeatConn:Disconnect()
		heartbeatConn = nil
	end

	clearParts()
	warn("[LoadHarness] STOPPED")
end

local function start()
	if Settings.enabled then return end
	Settings.enabled = true
	startedAt = now()
	throwAccumulator = 0

	ensureParts()

	heartbeatConn = RunService.Heartbeat:Connect(function(dt)
		if not Settings.enabled then return end

		-- auto stop
		if Settings.durationSec > 0 and (now() - startedAt) >= Settings.durationSec then
			warn("[LoadHarness] Duration reached, auto-stopping.")
			stop()
			return
		end

		-- keep part count in sync
		ensureParts()

		-- physics stress
		applyPhysics(dt)

		-- CPU stress
		burnCpu(Settings.cpuMsPerStep)
	end)

	warn(("[LoadHarness] STARTED | cpuMs=%d | parts=%d | throwRate=%d/s | duration=%ds")
		:format(Settings.cpuMsPerStep, Settings.maxParts, Settings.throwRatePerSec, Settings.durationSec))
end

local function status()
	warn(("[LoadHarness] enabled=%s | cpuMs=%d | parts=%d | throwRate=%d/s | duration=%ds | players=%d")
		:format(
			tostring(Settings.enabled),
			Settings.cpuMsPerStep,
			Settings.maxParts,
			Settings.throwRatePerSec,
			Settings.durationSec,
			#Players:GetPlayers()
		))
end

-- Simple server-console command hook (type into Studio Server console)
local function parseCommand(msg: string)
	local args = string.split(msg, " ")
	if args[1] ~= "_load" then return end

	local cmd = args[2]
	if cmd == "start" then
		start()
	elseif cmd == "stop" then
		stop()
	elseif cmd == "status" then
		status()
	elseif cmd == "set" then
		local key = args[3]
		local val = tonumber(args[4])
		if not key or val == nil then
			warn("[LoadHarness] Usage: _load set cpuMs|parts|throwRate|duration <number>")
			return
		end

		if key == "cpuMs" then
			Settings.cpuMsPerStep = math.clamp(math.floor(val), 0, 50)
		elseif key == "parts" then
			Settings.maxParts = math.clamp(math.floor(val), 0, 2000)
		elseif key == "throwRate" then
			Settings.throwRatePerSec = math.clamp(math.floor(val), 0, 200)
		elseif key == "duration" then
			Settings.durationSec = math.max(0, math.floor(val))
		else
			warn("[LoadHarness] Unknown key:", key)
			return
		end

		warn("[LoadHarness] Updated:", key, val)
		if Settings.enabled then
			ensureParts()
		end
	else
		warn("[LoadHarness] Commands: _load start | _load stop | _load status | _load set cpuMs|parts|throwRate|duration <n>")
	end
end

-- Studio server console messages are not directly exposed, so we use a safe in-game chat trigger:
-- Only players with UserId in allowedAdmins can run commands.
local allowedAdmins = {
	-- put your UserId(s) here
	-- [12345678] = true,
}

Players.PlayerAdded:Connect(function(plr)
	plr.Chatted:Connect(function(msg)
		if not allowedAdmins[plr.UserId] then return end
		parseCommand(msg)
	end)
end)

warn("[LoadHarness] Ready. Add your UserId to allowedAdmins, then use chat commands like: _load start")
